# Security controls covered by the Security Scanner for Azure DevOps (ADO)

This page displays security controls that are automated via ADO security scanner and also controls that have to manually verified. Controls have a 'Severity' field to help distinguish issues by degree of risk. Apart from that the automated flag indicates whether a particular control is automated and 'Fix Script' provides the availability of  a 'control fix' script that the user can review and run to apply the fixes. 

## Azure DevOps resource types supported by the AzSK.ADO scanner module

Below resource types can be checked for validating the security controls. 

|FeatureName|
|---|
|[Organization](#Organization)|
|[Project](#Project)|
|[Build](#Build)|
|[Release](#Release)|
|[ServiceConnection](#Service-Connection)|
|[Agent Pool](#Agent-Pool)|
|[User](#User)|
|[VariableGroup](#VariableGroup)|
|[CommonSVTControls](#CommonSVTControls)|

## Organization

<body>
<H2>Organization</H2><table><tr><th>Description & Rationale</th><th>ControlSeverity</th><th>Automated</th></tr><tr><td><b>Organization must be configured to authenticate users using Azure Active Directory backed credentials.</b><br/>Using the native enterprise directory for authentication ensures that there is a built-in high level of assurance in the user identity established for subsequent access control. All enterprise organizations are automatically associated with their enterprise directory (xxx.onmicrosoft.com) and users in the native directory are trusted for authentication to enterprise organizations.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not enable access for external users in your organization.</b><br/>Non-AD accounts (such as xyz@hotmail.com, pqr@outlook.com, etc.) present at any scope within a organization subject your assets to undue risk. These accounts are not managed to the same standards as enterprise tenant identities. They don't have multi-factor authentication enabled.</td><td>High</td><td>Yes</td></tr><tr><td><b>Public projects should be turned off for your organization.</b><br/>Data/content in projects that have anonymous access can be downloaded by anyone on the internet without authentication. This can lead to a compromise of corporate data/assets.</td><td>High</td><td>Yes</td></tr><tr><td><b>Justify all guest members that have been granted access to your organization.</b><br/>Guest user accounts are not carefully managed and governed. If these accounts have admin access then a compromised account can be easily leveraged to access arbitrary resources in the organization.</td><td>High</td><td>Yes</td></tr><tr><td><b>Carefully review all extensions enabled for your organization.</b><br/>Running extensions from untrusted source can lead to all type of attacks and loss of sensitive enterprise data/assets.</td><td>High</td><td>Yes</td></tr><tr><td><b>Exercise due care when installing (private) shared extensions for your organization.</b><br/>Shared extensions can be risky because they might undergo even lesser scrutiny from a security standpoint.</td><td>High</td><td>Yes</td></tr><tr><td><b>Review the set of users who have permission to manage extensions.</b><br/>Users with extension manager role can install/manage extensions for the organization. By carefully reviewing and removing users that shouldn't be in this role, you can avoid attacks if those user accounts are compromised.</td><td>High</td><td>Yes</td></tr><tr><td><b>Consider revoking access for inactive users in your organization.</b><br/>Each additional person having access at organization level increases the attack surface for the entire resources. To minimize this risk ensure that critical resources present in organization are accessed only by the legitimate users when required.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Remove access for users whose accounts have been deleted/disconnected from Azure Active Directory.</b><br/>Cleaning up/removing RBAC entries for users who have left the organization is a good security hygiene practice.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Review membership of all organization level privileged groups and teams.</b><br/>Accounts that are a member of these groups without a legitimate business reason increase the risk for your Organization. By carefully reviewing and removing accounts that shouldn't be there in the first place, you can avoid attacks if those accounts are compromised.</td><td>High</td><td>No</td></tr><tr><td><b>Alerts must be configured for critical actions on Organization</b><br/>Alerts notify the configured security point of contact about various sensitive activities on the Organization and its resources (for instance, external Extensions have been installed/modified etc.)</td><td>Medium</td><td>No</td></tr><tr><td><b>Service accounts cannot support MFA and should not be used for organization activity.</b><br/>Service accounts are typically not multi-factor authentication capable. Quite often, teams who own these accounts don't exercise due care (e.g., someone may login interactively on servers using a service account exposing their credentials to attacks such as pass-the-hash, phishing, etc.) As a result, using service accounts in any privileged role in ADO exposes the Organization data to 'credential theft'-related attack vectors. (In effect, the Organization data becomes accessible after just one factor (password) is compromised...this defeats the whole purpose of imposing the MFA requirement for Organizations.)</td><td>High</td><td>No</td></tr><tr><td><b>Alternate (ALT) accounts should be used from Secure Admin Workstation (SAW) for privileged organization roles.</b><br/>Corporate accounts are subject to a lot of credential theft attacks due to various activities that a user conducts using such accounts (e.g., browsing the web, clicking on email links, etc.). A user account that gets compromised (say via a phishing attack) immediately subjects the entire Azure DevOps organization to risk if it is privileged with critical roles in the organization. Use of smartcard-backed alternate (SC-ALT) accounts instead protects the organization from this risk.</td><td>High</td><td>No</td></tr><tr><td><b>Alternate (ALT) accounts must be used for administrative activity at organization scope.</b><br/>Corporate accounts are subject to a lot of credential theft attacks due to various activities that a user conducts using such accounts (e.g., browsing the web, clicking on email links, etc.). A user account that gets compromised (say via a phishing attack) immediately subjects the entire Azure DevOps organization to risk if it is privileged with critical roles in the organization. Use of smartcard-backed alternate (SC-ALT) accounts instead protects the organization from this risk.</td><td>High</td><td>Yes</td></tr><tr><td><b>Review and minimize accounts that are members of the Project Collection Service Accounts group.</b><br/>Any accounts that are members of Project Collection Service Accounts are effectively Project Collection Administrators. If an adversary compromises one of these accounts they can take over the entire ADO organization.</td><td>High</td><td>Yes</td></tr><tr><td><b>Set of auto-injected pipeline tasks should be carefully scrutinized.</b><br/>Auto-injected pipeline tasks will run in every pipeline. If an attacker can change/influence the task logic/code, it can have catastrophic consequences for the entire organization.</td><td>High</td><td>Yes</td></tr><tr><td><b>Consider disabling enterprise access to projects in your organization.</b><br/>If enterprise access to projects is enabled, data/content in enterprise projects can be viewed/downloaded by anyone within the organization. This can lead to a compromise of sensitive corporate data.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Consider enabling AAD conditional access policy for your organization.</b><br/>Enabling AAD conditional access policy helps manage organization restrictions on security group membership, location and network identity, specific operating system and enabled device in a management system.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Disable anonymous access to status badge API for parallel pipelines.</b><br/>Information that appears in the status badge API response should be hidden from external users.</td><td>Low</td><td>Yes</td></tr><tr><td><b>Allow queue time changes only to pipeline variables explicitly marked as settable.</b><br/>By default a pipeline user can set any variables at queue time unless this option is enabled. Enabling this setting enforces that variables must be explicitly marked settable at queue-time as needed.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Limit scope of access for non-release pipelines to the current project.</b><br/>If the authorization scope of non-release pipelines is not limited to current project, an attacker can build a pipeline from a different (less sensitive project) to access resources in a target (more sensitive) project. This also in keeping with the principle of least privilege.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Limit scope of access for release pipelines to the current project.</b><br/>If the authorization scope of release pipelines is not limited to current project, an attacker can build a pipeline from a different (less sensitive project) to access resources in a target (more sensitive) project. This also in keeping with the principle of least privilege.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Limit scope of access for pipelines to explicitly referenced Azure DevOps repositories.</b><br/>If the authorization scope of pipelines is not limited to referenced repos, an attacker can create a pipeline that can access sensitive repos within the project. This is in keeping with the principle of least privilege.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Review if project and team admins should be allowed to invite new users.</b><br/>By default, all administrators can invite new users to Azure DevOps. In some environments, you may want to restrict this setting so that new users can be invited only by organization admins.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Backup audit logs to an external location periodically.</b><br/>By default, ADO keeps audit logs for 90 days. Most sensitive operation logs should be retained for 365 days (Auditing contains many changes that occur throughout an Azure DevOps organization. Changes occur when a user or service identity within the organization edits the state of an artifact. In some limited cases, it can also include accessing an artifact. Think permissions changes, resource deletion, branch policy changes, accessing the auditing feature, and much more.).</td><td>Medium</td><td>No</td></tr><tr><td><b>Enable audit streaming to support alerting, monitoring and analysis of audit logs over longer periods.</b><br/>Enabling audit streaming sends data to other locations for further processing. Sending auditing data to other Security Incident and Event Management (SIEM) tools opens possibilities, such as alerting on specific auditing events, creating views on auditing data, and performing anomaly detection. It also allows you to store more than 90 days of auditing data.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Ensure that there are at most 6 project collection administrators in your organization.</b><br/>Each additional person in the administrator role increases the attack surface for the entire organization (if an admin's account is compromised via phishing attack). The number of members in these roles should be kept to as low as possible.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Ensure that there are at least 2 project collection administrators in your organization.</b><br/>Having at least the minimum required number of administrators reduces the risk of losing admin access. This is useful in case of breakglass scenarios.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Third-party application access via OAuth should be disabled.</b><br/>Malicious ADO OAuth applications can be used to phish ADO admins or users. OAuth app access should be disabled if your organization does not use any third-party OAuth application.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Carefully review requested extensions for your organization.</b><br/>Approving and running extensions from untrusted source can lead to all type of attacks and loss of sensitive enterprise data.</td><td>High</td><td>Yes</td></tr><tr><td><b>Connecting to Git repos via SSH should be disabled.</b><br/>Malicious SSH connections to ADO repos can be used to extract sensitive code/content leading to compromise of corporate data.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Remove access for inactive guest users from your organization.</b><br/>Guest accounts present at any scope within an organization subject your assets to undue risk. These accounts are not managed to the same standards as native enterprise identities. They don't have multi-factor authentication enabled, etc. Even where needed for business purposes, such accounts should be promptly removed if they have not been active for a specified period.</td><td>High</td><td>Yes</td></tr><tr><td><b>Remove guest users from administrative roles in your organization.</b><br/>Guest user accounts are not carefully managed and governed. If these accounts have admin access then a compromised account can be easily leveraged to access arbitrary resources in the organization.</td><td>High</td><td>Yes</td></tr><tr><td><b>Remove inactive users from administrative roles in your organization.</b><br/>Inactive users in administrative roles provide opportunities for hackers to leverage credential harvesting attacks to gain admin access. It is best to restrict critical roles in the organization to active members only.</td><td>High</td><td>Yes</td></tr><tr><td><b>Disable request access policy in your organization.</b><br/>Access to the ADO instance should be allowed by only joining standard groups set up the respective teams while onboarding. If the setting is on, an admin may hurriedly grant access to a potentially malicious user who can use this to access the instance and laterally move around groups, bypassing the designed security model.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Do not allow feeds to inherit excessive permissions for a broad group of users at organization level.</b><br/>If a broad group (e.g., Contributors) is configured with excessive permissions at a organization level, they are inherited by individual feeds and can not be removed at individual feed level regardless of role. The integrity of feeds can be compromised by a malicious user from such groups.</td><td>High</td><td>Yes</td></tr><tr><td><b>Allow only limited group of users permission to create feeds in the organization.</b><br/>If everyone in the organization is granted permission to create feeds, it leads to poor governance and high possibility of attacks that leverage tampering with feeds to impact downstream consumers.</td><td>High</td><td>Yes</td></tr><tr><td><b>Enable protection from externally sourced packages in Azure Artifacts feeds.</b><br/>Enabling this setting provides an additional layer of security by preventing malicious packages from a public registry being inadvertently consumed. This secures your private feed by limiting access to externally sourced packages. If not set, an attacker can publish a malicious (newer) version of an internal feed package and get it to be consumed by unsuspecting users/pipelines.</td><td>High</td><td>Yes</td></tr></table>
<table>
</table>
</body>


## Project

<table><tr><th>Description & Rationale</th><th>ControlSeverity</th><th>Automated</th></tr><tr><td><b>Ensure that project visibility is set to either private or enterprise.</b><br/>Data/content in projects that have public visibility can be downloaded by anyone on the internet without authentication. This can lead to a compromise of corporate data/assets.</td><td>High</td><td>Yes</td></tr><tr><td><b>Review membership of all project level privileged groups and teams.</b><br/>Accounts that are a member of these groups without a legitimate business reason increase the risk for your Organization. By carefully reviewing and removing accounts that shouldn't be there in the first place, you can avoid attacks if those accounts are compromised.</td><td>High</td><td>No</td></tr><tr><td><b>Disable anonymous access to status badge API for parallel pipelines.</b><br/>Information that appears in the status badge API response should be hidden from external users.</td><td>Low</td><td>Yes</td></tr><tr><td><b>Allow queue time changes only to pipeline variables explicitly marked as settable.</b><br/>By default a pipeline user can set any variables at queue time unless this option is enabled. Enabling this setting enforces that variables must be explicitly marked settable at queue-time as needed.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Limit scope of access for non-release pipelines to the current project.</b><br/>If the authorization scope of non-release pipelines is not limited to current project, an attacker can build a pipeline from a different (less sensitive project) to access resources in a target (more sensitive) project. This also in keeping with the principle of least privilege.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Limit scope of access for release pipelines to the current project.</b><br/>If the authorization scope of release pipelines is not limited to current project, an attacker can build a pipeline from a different (less sensitive project) to access resources in a target (more sensitive) project. This also in keeping with the principle of least privilege.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Limit scope of access for pipelines to explicitly referenced Azure DevOps repositories.</b><br/>If the authorization scope of pipelines is not limited to referenced repos, an attacker can create a pipeline that can access sensitive repos within the project. This also in keeping with the principle of least privilege.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Consider using artifact evaluation for fine-grained control over pipeline stages.</b><br/>Allow pipelines to record metadata. Evaluate artifact check can be configured to define policies using the metadata recorded.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Ensure that there are at most 6 project administrators in your project.</b><br/>Each additional person in the administrator role increases the attack surface for the entire project (if an admin's credentials are compromised via a phishing attack). The number of members in these roles should be kept as low as possible.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Ensure that there are at least 2 project administrators in your project.</b><br/>Having the minimum required number of administrators reduces the risk of losing admin access. This is useful in case of breakglass scenarios.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Alternate (ALT) accounts must be used for administrative activity at project scope.</b><br/>Corporate accounts are subject to a lot of credential theft attacks due to various activities that a user conducts using such accounts (e.g., browsing the web, clicking on email links, etc.). A user account that gets compromised (say via a phishing attack) immediately subjects the entire Azure DevOps organization to risk if it is privileged with critical roles in the organization. Use of smartcard-backed alternate (SC-ALT) accounts instead protects the organization from this risk.</td><td>High</td><td>Yes</td></tr><tr><td><b>Enable commit author email validation to restrict commits to repositories from untrusted users.</b><br/>Allowing commits from untrusted users can be dangerous as any malicious actor can push changes that can expose secrets/vulnerabilities outside the organization.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Enable credential scanner to block pushes that contain credentials and other secrets.</b><br/>Exposed credentials in engineering systems continue to provide easily exploitable opportunities for attackers. To defend against this threat, Microsoft security experts developed the CredScan tool to automatically find exposed secrets. CredScan indexes and scans for credentials & other sensitive content in source code, as well as other data sources.</td><td>High</td><td>Yes</td></tr><tr><td><b>Projects with no development activity (no active builds, releases, repos, agent pools, service connections, etc.) should be deleted.</b><br/>Projects which have no activity are likely to be abandoned efforts. It is recommended to delete such projects to minimize exposure of corporate assets, credentials, etc.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Remove guest users from administrative roles in your project.</b><br/>Guest user accounts are not carefully managed and governed. If these accounts have admin access then a compromised account can be easily leveraged to access arbitrary resources in the project.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not allow build pipelines to inherit excessive permissions for a broad group of users at project level.</b><br/>If a broad group (e.g., Contributors) is configured with excessive permissions at a project level, they are inherited by individual build pipelines in the project. A malicious user can abuse these permissions to compromise the security of the pipeline.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not allow release pipelines to inherit excessive permissions for a broad group of users at project level.</b><br/>If a broad group (e.g., Contributors) is configured with excessive permissions at a project level, they are inherited by individual release pipelines in the project. A malicious user can abuse these permissions to compromise the security of the pipeline.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not allow service connections to inherit excessive permissions for a broad group of users at project level.</b><br/>If a broad group (e.g., Contributors) is configured with excessive permissions at a project level, they are inherited by individual service connections in the project. Then the confidentiality/integrity of a pipeline using such service connections can be compromised by a malicious user.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not allow agent pools to inherit excessive permissions for a broad group of users at project level.</b><br/>If a broad group (e.g., Contributors) is configured with excessive permissions at a project level, they are inherited by individual agent pools in the project. Then integrity of such agent pools can be compromised by a malicious user</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not allow variable groups to inherit excessive permissions for a broad group of users at project level.</b><br/>If a broad group (e.g., Contributors) is configured with excessive permissions at a project level, they are inherited by individual variable groups in the project. Then the integrity of variable groups can be compromised by a malicious user</td><td>High</td><td>Yes</td></tr><tr><td><b>Remove inactive users from administrative roles in your project.</b><br/>Inactive users in administrative roles provide more opportunities for hackers to leverage credential harvesting attacks to gain admin access. It is best to restrict critical roles in the project to active members only.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not allow environments to inherit excessive permissions for a broad group of users at project level.</b><br/>If a broad group (e.g., Contributors) is configured with excessive permissions at a project level, they are inherited by individual environments in the project. Then the integrity of environments can be compromised by a malicious user.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not allow repositories to inherit excessive permissions for a broad group of users at project level.</b><br/>If a broad group (e.g., Contributors) is configured with excessive permissions at a project level, they are inherited by individual repositories in the project. Then the integrity of repository can be compromised by a malicious user.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not allow secure files to inherit excessive permissions for a broad group of users at project level.</b><br/>If a broad group (e.g., Contributors) is configured with excessive permissions at a project level, they are inherited by individual secure files in the project. Then the integrity of secure files can be compromised by a malicious user.</td><td>High</td><td>Yes</td></tr><tr><td><b>Ensure that there are at most 100 build administrators in your project.</b><br/>Each additional person in the build administrator role increases the attack surface for the entire project (if an admin's credentials are compromised via a phishing attack). A compromised account of this group can create/tamper resources such as builds and task groups. The number of members in these roles should be kept as low as possible.</td><td>Medium</td><td>Yes</td></tr></table>
<table>
</table>

## Build

<table><tr><th>Description & Rationale</th><th>ControlSeverity</th><th>Automated</th></tr><tr><td><b>Secrets and keys must not be stored as plain text in build variables/task parameters.</b><br/>Keeping secrets such as connection strings, passwords, keys, etc. in plain text can expose the credentials to a wider audience and can lead to credential theft. Marking them as secret protects them from unitended disclosure and/or misuse.</td><td>High</td><td>Yes</td></tr><tr><td><b>Consider adding static code analysis step in your pipelines.</b><br/>Static code analyzers ensure that many kinds of security vulnerabilities are detected in early stages of software/service development.</td><td>High</td><td>No</td></tr><tr><td><b>Secure Files library must be used to store secret files such as signing certificates, Apple Provisioning Profiles, Android KeyStore files, and SSH keys</b><br/>The contents of the secure files are encrypted and can only be used during the build or release pipeline by referencing them from a task.</td><td>Medium</td><td>No</td></tr><tr><td><b>Inactive build pipelines must be removed if no more required.</b><br/>Each additional build having access to repositories increases the attack surface. To minimize this risk ensure that only active and legitimate build pipelines are present in your environment.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Do not allow inherited permission on build definitions.</b><br/>Disabling inherited permissions lets you finely control access to various operations at the build level for different stakeholders. This ensures that you follow the principle of least privilege and provide access only to the persons that require it.</td><td>High</td><td>Yes</td></tr><tr><td><b>Pipeline variables marked settable at queue time should be carefully reviewed.</b><br/>Pipeline variables that are marked settable at queue time can be changed by anyone who can queue a build. Such variables can be misused for code injection/data theft attacks from pipelines.</td><td>High</td><td>Yes</td></tr><tr><td><b>Pipeline variables marked settable at queue time and containing URLs should be avoided.</b><br/>Pipeline variables that are marked settable at queue time can be changed by anyone who can queue a build. If these variables contain a URL then someone can change the URL to a server that they control and can intercept any secrets used to interact with the intended server by queueing a build.</td><td>High</td><td>Yes</td></tr><tr><td><b>Review external source code repositories before adding them to your pipeline.</b><br/>Building code from untrusted external sources can allow an attacker to execute arbitrary code in your pipeline. Hence, all repositories added to the pipeline should be carefully reviewed.</td><td>High</td><td>Yes</td></tr><tr><td><b>Builds should not use task groups that are editable by a broad pool of users.</b><br/>If a broad pool of users (e.g., Contributors) have edit permissions on a task group, then integrity of your pipeline can be compromised by a malicious user who edits the task group.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not use variable groups that are editable by a broad group of users.</b><br/>If a broad group of users (e.g., Contributors) have edit permissions on a variable group, then integrity of your pipeline can be compromised by a malicious user who edits the variable group.</td><td>High</td><td>Yes</td></tr><tr><td><b>Limit scope of access for build pipeline to the current project.</b><br/>If pipelines use project collection level tokens, a vulnerability in components used by one project can be leveraged by an attacker to attack all other projects. This is also in keeping with the principle of least privilege.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Do not allow build pipeline to have excessive permissions by a broad group of users.</b><br/>If a broad group of users (e.g., Contributors) have excessive permissions on a pipeline, a malicious user can abuse these permissions to compromise security of the pipeline.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not make secrets available to builds for fork of public repository.</b><br/>For GitHub public repositories, it is possible that people from outside the organization can create forks and run builds on the forked repo. In such a case, if this setting is wrongly left enabled, outsiders can get access to build pipeline secrets that were meant to be internal.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not allow build pipeline to build code from forked repository on self-hosted agent.</b><br/>If you use GitHub open-source projects, anyone with a GitHub account can fork your repository and propose contributions back. Since pipelines are associated with a repository and not with specific branches, you must assume the code and YAML files are untrusted. (https://docs.microsoft.com/en-us/azure/devops/pipelines/security/repos?view=azure-devops)</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Do not run continuous integration or scheduled builds on untrusted code from external or public GitHub repositories.</b><br/>Build agents posess a token scoped to either current project or project collection. This token is available to builds triggered via the Continuous Integration and Scheduled Build mechanisms. If an adversary pushed a malicious commit to the upstream public GitHub repo, they can exfiltrate the token and use it to move laterally throughout the ADO organization (or Project).</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Do not allow agent jobs to access OAuth token unless explicitly required.</b><br/>Malicious task or extensions can use Oauth access token for stealing project details like builds,releases,agent pools etc.</td><td>Medium</td><td>Yes</td></tr></table>
<table>
</table>

## Release

<table><tr><th>Description & Rationale</th><th>ControlSeverity</th><th>Automated</th></tr><tr><td><b>Secrets and keys must not be stored as plain text in release variables/task parameters.</b><br/>Keeping secrets such as connection strings, passwords, keys, etc. in plain text can expose the credentials to a wider audience and can lead to credential theft. Marking them as secret protects them from unitended disclosure and/or misuse.</td><td>High</td><td>Yes</td></tr><tr><td><b>Inactive release pipelines must be removed if no more required.</b><br/>Each additional release having access to repositories/other artifacts increases the attack surface. To minimize this risk ensure that only active and legitimate release pipelines are present in your environment.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Do not allow inherited permission on release definitions</b><br/>Disabling inherited permissions lets you finely control access to various operations at the release level for different stakeholders. This ensures that you follow the principle of least privilege and provide access only to the persons that require it.</td><td>High</td><td>Yes</td></tr><tr><td><b>Releases pipeline for production deployments must have pre-deployment approval enabled.</b><br/>Pre-deployment approvals give you an additional layer of defense against inadvertent (or possibly malicious) changes to your production environment.</td><td>High</td><td>Yes</td></tr><tr><td><b>Only legitimate users should be added as approvers for releases.</b><br/>Periodic review of approvers list for production releases ensures that only appropriate people are members of such a critical role. As team composition/membership changes, this privilege may need to be revoked from members who are no more in the team.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>All releases to production or pre-production stages must be done from one and only one (main) branch.</b><br/>You should ensure that production releases are always done from one and only one (main) branch. The main branch should have the tightest access controls and approval standards. Any changes in the source code should be tested first on a development branch before merging in the main branch. The source code in the main branch should correspond to production bits at all times. This helps in maintaining stable source code and helps prevent deployment of breaking changes (and potential security bugs) into the production environment.</td><td>Medium</td><td>No</td></tr><tr><td><b>Review external source code repositories before adding them to your pipeline.</b><br/>Building code from untrusted external sources can allow an attacker to execute arbitrary code in your pipeline. Hence, all repositories added to the pipeline should be carefully reviewed.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Pipeline variables marked settable at release time should be carefully reviewed.</b><br/>Pipeline variables that are marked settable at queue time can be changed by anyone who can create a release. Such variables can be misused for code injection/data theft attacks from pipelines.</td><td>High</td><td>Yes</td></tr><tr><td><b>Pipeline variables marked settable at release time and containing URLs should be avoided.</b><br/>Pipeline variables that are marked settable at queue time can be changed by anyone who can create a release. If these variables contain a URL then someone can change the URL to a server that they control and can intercept any secret used to interact with the intended server by creating a release.</td><td>High</td><td>Yes</td></tr><tr><td><b>Releases should not use task groups that are editable by a broad pool of users.</b><br/>If a broad pool of users (e.g., Contributors) have edit permissions on a task group, then integrity of your pipeline can be compromised by a malicious user who edits the task group.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not use variable groups that are editable by a broad group of users.</b><br/>If a broad group of users (e.g., Contributors) have edit permissions on a variable group, then integrity of your pipeline can be compromised by a malicious user who edits the variable group.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not allow release pipeline to be have excessive permissions by a broad group of users.</b><br/>If a broad group of users (e.g., Contributors) have excessive permissions on a pipeline, a malicious user can abuse these permissions to compromise security of the pipeline.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not allow agent jobs to access OAuth token unless explicitly required.</b><br/>Malicious task or extensions can use Oauth access token for stealing project details like builds,releases,agent pools etc.</td><td>Medium</td><td>Yes</td></tr></table>
<table>
</table>

## Service Connection

<table><tr><th>Description & Rationale</th><th>ControlSeverity</th><th>Automated</th></tr><tr><td><b>Azure Active Directory applications, which used in pipeline, must use certificate based authentication.</b><br/>Password/shared secret credentials can be easily shared and hence can be easily compromised. Certificate credentials offer better security.</td><td>High</td><td>Yes</td></tr><tr><td><b>Azure service connection should not be provided access at subscription/management group scope.</b><br/>SPN-based logins do not have MFA protection. It is important to restrict the access granted to Azure service connections only to specific resource/resource group as needed. This can contain the extent of damage in case of compromise.</td><td>High</td><td>Yes</td></tr><tr><td><b>Periodically review usage history of service connection to validate use from legitimate pipelines.</b><br/>Periodic reviews of request history logs ensures that sevice connection been used from legitimate build definitions and avoid major compromise.</td><td>High</td><td>No</td></tr><tr><td><b>Do not use classic Azure service connections to access a subscription.</b><br/>You should use Azure resource Manager type service connection as the ARM model provides several security enhancements such as: stronger access control (RBAC), better auditing, ARM-based deployment/governance, access to managed identities, access to key vault for secrets, AAD-based authentication, support for tags and resource groups for easier security management, etc.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not allow inherited permissions on service connections.</b><br/>Service connections represent credentials of various services/repositories accessed by your project's build/release process. You should exercise fine-grained control over who can access them. Removing inherited access ensures that individuals beyond your control do not get access.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not grant global groups access to service connections.</b><br/>Global groups are maintained at organization and project level and may contain users at a very broad scope (e.g., all users in the organization). Granting elevated permissions to these groups can risk exposure of service connections to unwarranted individuals.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not grant Build Service Account direct access to service connections</b><br/>Build service account is default identity used as part every build in project. Providing direct access to this common service account will expose connection details to all build definitions in the project.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not make service connection accessible to all (YAML) pipelines.</b><br/>To support security of the pipeline operations, connections must not be granted access to all YAML pipelines. This is in keeping with the principle of least privilege because a vulnerability in components used by one pipeline can be leveraged by an attacker to attack other pipelines having access to critical resources. Note that this does not prevent classic pipelines from accessing the service connection as it depends on the permissions granted to pipeline user.</td><td>High</td><td>Yes</td></tr><tr><td><b>Service connections should use strong authentication methods.</b><br/>Weaker authentication methods such as basic authentication can be easily compromised. Stronger authentication methods (certificate, token etc.) offer better security.</td><td>High</td><td>Yes</td></tr><tr><td><b>Inactive service connection must be removed if no more required.</b><br/>Each inactive service connection increases the window of attack for a malicious user who can use a service connection to access an underlying target resource such as repositories, storage account, azure subscriptions or a CI environment. To minimize this risk ensure that inactive service connections are proactively deleted.</td><td>High</td><td>Yes</td></tr><tr><td><b>Service connections should not be shared across multiple projects.</b><br/>If a service connection is shared across multiple projects, then a user in another project can access data/components that they were otherwise not supposed to access. So, in keeping with principle of least privilege, it is best to limit access to the service connection to your (current) project.</td><td>High</td><td>Yes</td></tr><tr><td><b>Ensure that service connection access is granted only to (YAML) pipelines that require it.</b><br/>If a service connection is shared across multiple pipelines, then a vulnerability in components used by one pipeline can be leveraged by an attacker to attack other pipelines having access to critical resources. This is also in keeping with the principle of least privilege.</td><td>High</td><td>Yes</td></tr><tr><td><b>Broader groups (contributors, project valid users, etc.) should not have excessive permissions on service connection.</b><br/>If broader groups (e.g., Contributors) have excessive permissions (Admin/User) on service connection, then confidentiality/integrity of a pipeline using the service connection can be compromised by a malicious user. Removing access/privileges that are not required minimizes exposure of the resources in case of user account/service connection compromise.</td><td>High</td><td>Yes</td></tr><tr><td><b>Azure service connections to certain environments are not permitted from this org.</b><br/>Service connection should not connect to restricted cloud environments to align with data sovereignty requirements and ensure their data and workloads stays in allowed cloud environments.</td><td>High</td><td>Yes</td></tr></table>
<table>
</table>
 
 ## Agent Pool

<table><tr><th>Description & Rationale</th><th>ControlSeverity</th><th>Automated</th></tr><tr><td><b>Non-hosted agent virtual machine must have all the required security patches installed.</b><br/>Unpatched VMs are easy targets for compromise from various malware/trojan attacks that exploit known vulnerabilities in operating systems and related software.</td><td>High</td><td>No</td></tr><tr><td><b>Use a security hardened, locked down OS image for self-hosted VMs in agent pool.</b><br/>The connector machine is serving as a 'gateway' into the corporate environment allowing internet based client endpoints access to enterprise data. Using a locked-down, secure baseline configuration ensures that this machine does not get leveraged as an entry point to attack the applications/corporate network.</td><td>Medium</td><td>No</td></tr><tr><td><b>Do not allow inherited permission on agent pool.</b><br/>Disabling inherit permissions lets you finely control access to various operations at the agent level for different stakeholders. This ensures that you follow the principle of least privilege and provide access only to the persons that require it.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not enable auto-provisioning for agent pools.</b><br/>By enabling auto-provisioning the organization agent pool is imported in all your new team projects and is accessible there immediately. Therefore, a vulnerability in components used by one project can be leveraged by an attacker to attack other projects.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not make agent pool accessible to all (YAML) pipelines in the project.</b><br/>To support security of the pipeline operations, agent pools must not be granted access to all YAML pipelines. This is in keeping with the principle of least privilege because a vulnerability in components used by one pipeline can be leveraged by an attacker to attack other pipelines having access to critical resources. Note that this does not prevent classic pipelines from accessing the agent pool as it depends on the permissions granted to pipeline user.</td><td>High</td><td>Yes</td></tr><tr><td><b>Inactive agent pools must be removed if no more required.</b><br/>Agent pools may contain potentially sensitive information (such as code, secrets, pre-release information and logs) from previously run pipelines. Thus each inactive agent pool can increase the exposure of such important information to a malicious user. To minimize this risk ensure that inactive agent pools are proactively deleted.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Enable auto-update of agents in the pool.</b><br/>Unpatched agents are easy targets for compromise from various malware/trojan attacks that exploit known vulnerabilities in operating systems and related software. Being on the latest OS version significantly reduces risks from security design issues and security bugs that may be present in older versions.</td><td>High</td><td>Yes</td></tr><tr><td><b>Secrets and keys must not be stored as plain text in agent capabilities.</b><br/>Keeping secrets such as connection strings, passwords, keys, etc. as a plain text in agent capabilities can expose the credentials to a wider audience and lead to credential theft. Any user who can deploy a pipeline to run on such agents can access these secrets and compromise the security of resources involving the secrets.</td><td>High</td><td>Yes</td></tr><tr><td><b>Broader groups (contributors, project valid users, etc.) should not have excessive permissions on agent pool.</b><br/>If broader groups (e.g., Contributors) have excessive permissions (Admin/User) on an agent pool, integrity of your agent pool can be compromised by a malicious user. Removing access/privileges that are not required minimizes exposure of the resources in case of user account/agent pool compromise.</td><td>High</td><td>Yes</td></tr></table>
<table>
</table>

## User

<table><tr><th>Description & Rationale</th><th>ControlSeverity</th><th>Automated</th></tr><tr><td><b>Personal access tokens (PAT) must be defined with minimum required permissions to resources</b><br/>Granting minimum access ensures that PAT is granted with just enough permissions to perform required tasks. This minimizes exposure of the resources in case of PAT compromise.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Personal access tokens (PAT) must have a shortest possible validity period</b><br/>If a personal access token (PAT) gets compromised, the Azure DevOps assets accessible to the user can be accessed/manipulated by unauthorized users. Minimizing the validity period of the PAT ensures that the window of time available to an attacker in the event of compromise is small.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Personal access tokens (PAT) near expiry should be renewed.</b><br/>Personal access tokens (PAT) near expiry should be renewed.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Alternate credentials must be disabled</b><br/>Alternate credential allows user to create username and password to access your Git repository.Login with these credentials doesn't expire and can't be scoped to limit access to your Azure DevOps Services data.</td><td>Medium</td><td>No</td></tr><tr><td><b>Do not use personal access tokens (PATs) that are scoped across multiple organizations.</b><br/>If a personal access token (PAT) gets compromised, the Azure DevOps assets accessible to the user can be accessed/manipulated by unauthorized users. Restricting the access to individual organizations reduces the exposure of resources to just the organization in an event of compromise.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Do not use personal access tokens (PATs) that have critical permissions on the organization unless required.</b><br/>Granting minimum access ensures that PAT is granted with just enough permissions to perform required tasks. This minimizes exposure of the resources in case of PAT compromise.</td><td>Medium</td><td>Yes</td></tr></table>
<table>
</table>

## VariableGroup

<table><tr><th>Description & Rationale</th><th>ControlSeverity</th><th>Automated</th></tr><tr><td><b>Do not make variable groups with secret variables accessible to all (YAML) pipelines.</b><br/>If a variable group containing secrets is marked as accessible to all YAML pipelines then an attacker can extract or compromise the assets involving the secret variables by creating a new pipeline. Note that this does not prevent classic pipelines from accessing the variable group as it depends on the permissions granted to pipeline user.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not allow inherited permissions on variable groups.</b><br/>Disabling inherited permissions lets you finely control access to various operations at the variable group level for different stakeholders. This ensures that you follow the principle of least privilege and provide access only to the persons that require it.</td><td>High</td><td>Yes</td></tr><tr><td><b>Secrets and keys must not be stored as plain text in variable group variables.</b><br/>Keeping secrets such as connection strings, passwords, keys, etc. in plain text can expose the credentials to a wider audience and can lead to credential theft. Marking them as secret protects them from unitended disclosure and/or misuse.</td><td>High</td><td>Yes</td></tr><tr><td><b>Consider using a linked Azure key vault for secret variables of the variable group.</b><br/>Storing secrets in a custom variable group is less secure than storing them in Azure key vault and selectively mapping it to the variable group as Key Vault offers an extra layer of security (identity & management, network access and monitoring).</td><td>Low</td><td>No</td></tr><tr><td><b>Broader groups (contributors, project valid users, etc.) should not have excessive permissions on variable group.</b><br/>If the broader groups (e.g., Contributors) have excessive permissions (Admin) on variable group, then integrity of your variable group can be compromised by a malicious user. Removing access/privileges that are not required minimizes exposure of the resources in case of user account/variable group compromise.</td><td>High</td><td>Yes</td></tr><tr><td><b>Broader groups (contributors, project valid users, etc.) should not have user/administrator privileges on variable group which contains secrets.</b><br/>If a broad group of users (e.g., Contributors) have excessive permissions on variable group, a malicious user can abuse these permissions to compromise security of the variable group as well as the assets involving the secret variables.</td><td>High</td><td>Yes</td></tr></table>
<table>
</table>

## CommonSVTControls

<table><tr><th>Description & Rationale</th><th>ControlSeverity</th><th>Automated</th></tr><tr><td><b>Inactive repositories must be removed if no more required.</b><br/>Each additional repository being accessed by pipelines increases the attack surface. To minimize this risk ensure that only active and legitimate repositories are present in project.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Do not make repository accessible to all (YAML) pipelines.</b><br/>If a repository is granted access to all YAML pipelines, an unauthorized user can steal information from the repository by building a pipeline and accessing the repository. Note that this does not prevent classic pipelines from accessing the repository as it depends on the permissions granted to pipeline user.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Do not grant build service groups excessive permissions on repository branches.</b><br/>If 'Project Collection Build Service' or 'Project Build Service' groups have excessive permissions on important branches of a repository, then a malicious user can access the repository and tamper its contents by bypassing any defined policies.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Do not allow a broad group of users to upload packages to feed.</b><br/>If a broad group of users (e.g., Contributors) have permissions to upload package to feed, then integrity of your pipeline can be compromised by a malicious user who uploads a package.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not grant Build Service Account direct access to feed.</b><br/>Build service account is default identity used as part every build in project. Providing direct access to this common service account will expose feeds to all build definitions in the project.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not make secure files accessible to all (YAML) pipelines.</b><br/>If a secure file is granted access to all YAML pipelines, an unauthorized user can steal information from the secure files by building a YAML pipeline and accessing the secure file. Note that this does not prevent classic pipelines from accessing the secure file as it depends on the permissions granted to pipeline user.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not allow secure file to have excessive permissions for a broad group of users.</b><br/>If a broad group of users (e.g. Contributors) have excessive permissions on a secure file, A malicious user may gain access of stored secret/certificate which may open the door to malicious attack (e.g. SSH for accessing machine/server using these secret/certifcate).</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not make environment accessible to all (YAML) pipelines.</b><br/>To support security of the pipeline operations, environments must not be granted access to all YAML pipelines. This is in keeping with the principle of least privilege because a vulnerability in components used by one pipeline can be leveraged by an attacker to attack other pipelines having access to critical resources. Note that this does not prevent classic pipelines from accessing the environment as it depends on the permissions granted to pipeline user.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not allow environment to have excessive permissions for a broad group of users.</b><br/>If a broad group of users (e.g., Contributors) have excessive permissions on an environment, a malicious user can abuse these permissions to compromise integrity of the environment.</td><td>High</td><td>Yes</td></tr><tr><td><b>Environments for production deployments must have approvals enabled.</b><br/>Approvals on an environment ensure that deployment from a YAML pipeline happens only after designated users have reviewed the changes being deployed. This provides an additional layer of defense against inadvertent (or possibly malicious) changes to your production environment.</td><td>High</td><td>Yes</td></tr><tr><td><b>Approvers on environment must be periodically reviewed.</b><br/>Periodic review of approvers list for production deployments ensures that only appropriate people are members of such a critical role. As team composition/membership changes, this privilege may need to be revoked from members who are no more in the team.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>All deployments to production environments must be done from standard branches.</b><br/>You should ensure that deployments to environments are always done from standard branches (like main, master and develop). These branches should have the tightest access controls and approval standards. Any changes in the source code should be tested first on a development branch before merging in the standard branches. The source code in these branches should correspond to production bits at all times. This helps in maintaining stable source code and helps prevent deployment of breaking changes (and potential security bugs) into the production environment.</td><td>Medium</td><td>Yes</td></tr><tr><td><b>Do not allow inherited permission on repository.</b><br/>Disabling inherited permissions lets you finely control access to various operations at the repository level for different stakeholders. This ensures that you follow the principle of least privilege and provide access only to the persons that require it.</td><td>High</td><td>Yes</td></tr><tr><td><b>Do not grant Build Service Account direct access to repositories.</b><br/>Build service account is default identity used as part every build in project. Configuring these identities with excessive permissions will expose repository details to all build definitions in the project.</td><td>High</td><td>Yes</td></tr><tr><td><b>Enable policy to block pushes that contain credentials and other secrets.</b><br/>Exposed credentials in engineering systems continue to provide easily exploitable opportunities for attackers. To defend against this threat, Microsoft security experts developed the CredScan tool to automatically find exposed secrets. CredScan indexes and scans for credentials & other sensitive content in source code, as well as other data sources. CredScan indexes and scans for credentials & other sensitive content in source code, as well as other data sources. CredScan should be enabled at each repo level to avoid commiting credentials or secrets.</td><td>High</td><td>Yes</td></tr><tr><td><b>Inactive feeds must be removed if no more required.</b><br/>Each additional feed increases the attack surface. An attacker can abuse an inactive feed to start publishing packages that might seem useful to other devs but have trojan horses inside. For good security hygiene and to minimize this risk, ensure that only active and legitimate feeds are present in your environment.</td><td>High</td><td>Yes</td></tr><tr><td><b>Inactive packages must be removed if no more required.</b><br/>Each additional feed package increases the attack surface. An attacker can abuse an inactive package to start publishing updates to such packages that might seem useful to other devs but have trojan horses inside. For good security hygiene and to minimize this risk, ensure that only active and legitimate packages are present in your environment.</td><td>Medium</td><td>Yes</td></tr></table>
<table>
</table>
